# MemoryShellCodeExploit
A POC using a dynamic compiler (CodeDOM) and TCPListener to run in memory and remotely malicius instructions

![Image of Yaktocat](https://static.thenounproject.com/png/45939-200.png)

# Basic Concept
Evade AV detection using dynamic compiler
### Step 1 - The malware is executed by the victim
### Step 2 - His load C# instructions from  (in string format in this exemple):
  - tcp/ip
  - http rest
  - Unamaged ressources / Managed Ressources
### Step 3 - The malware compile these instructions in memory and evade most AV.
  - To compile he can use:
  - Roslyn (+4.0 Framework)
  - CodeDOM (+2.0 Framework)
  - Mono
# Proof Of Concept
Run a shellcode msgbox over network from a file appenrently trusted.
In my case i have used :
- A TCP Listener on port 444 (Often open in compagny) on the attacker computer
- The C# CodeDOM compiler for most compatibility
- Differents unsafe C# instructions to loading the msgbox shellcode
![Image of Yaktocat](https://i.gyazo.com/43a872f3ae3eafde6d18164ce751e4da.gif)

Detections Ratio
- [First try 1/37 (Avira threats found)](https://metadefender.opswat.com/results#!/file/bzE5MDExN0J5VXh3RzFXQXpFSEp2Z3Z6a1dSek4/regular/overview)
  ![first_try_result](https://github.com/AzzRun/MemoryShellCodeExploit/blob/master/screens/firt_try.PNG?raw=true)

- [Second try 0/37 (No threats found](https://metadefender.opswat.com/results#!/file/bzE5MDExN0gxMG5aci1DZjRCazF4bldCYjBHNA/regular/overview)
  ![second_try_result](https://github.com/AzzRun/MemoryShellCodeExploit/blob/master/screens/second_try.PNG?raw=true)
 
 - Note: To bypass Avira i have  make differents manipulation (Merge assembly, and export sensible code to a library)
## Use Case (Same concept)

 - Execute a RunPe fully in memory to run a knowed malware
 - Use this network implement to run c# remotely
 - Make differents variant of malwares (signature, and polymorph)
 
## Librarys

I used [Protocol Buffer](https://developers.google.com/protocol-buffers/) for serialize/deserialize data sended over network.
I used [System.CodeDom.Compiler](https://docs.microsoft.com/fr-fr/dotnet/api/system.codedom.compiler?view=netframework-4.7.2) to compile C# instructions.
I used [System.Reflection Namespace](https://docs.microsoft.com/fr-fr/dotnet/api/system.reflection?view=netframework-4.7.2) to run compiled assembly in memory and evade AV.

## Authors

* **[Quentin Martinez](https://github.com/AzzRun)  - *Initial work* 

## License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details
